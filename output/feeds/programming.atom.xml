<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Travel Neil - programming</title><link href="http://pingzing.github.io/" rel="alternate"></link><link href="http://pingzing.github.io/feeds/programming.atom.xml" rel="self"></link><id>http://pingzing.github.io/</id><updated>2017-07-23T00:12:00+03:00</updated><entry><title>Talking to Win32 in Rust</title><link href="http://pingzing.github.io/talking-to-the-winapi-in-rust.html" rel="alternate"></link><published>2017-07-23T00:12:00+03:00</published><updated>2017-07-23T00:12:00+03:00</updated><author><name>Neil McAlister</name></author><id>tag:pingzing.github.io,2017-07-23:/talking-to-the-winapi-in-rust.html</id><summary type="html">&lt;p&gt;How to make Rust do your bidding&lt;/p&gt;</summary><content type="html">&lt;p&gt;I've &lt;a href="https://github.com/pingzing/articulator"&gt;done&lt;/a&gt; &lt;a href="https://github.com/pingzing/voicepipe"&gt;some&lt;/a&gt; &lt;a href="https://github.com/pingzing/oxide-skies/tree/master/src"&gt;dabbling&lt;/a&gt; in &lt;a href="https://www.rust-lang.org/en-US/"&gt;the Rust programming language&lt;/a&gt; in the past, so when a friend asked me if knew a way to force a VLC to the foreground in Windows with Rust, my answer was "yeah, probably".&lt;/p&gt;
&lt;p&gt;Of course, I got curious, so I wasn't willing to just let it lie--I started digging into it, and tried to figure it out for myself.&lt;/p&gt;
&lt;h2&gt;Planning&lt;/h2&gt;
&lt;p&gt;Doing anything involving windows in Windows inevtiably involves talking to the Win32 API, which means either programmming in C/C++, or using a bindings library to translate those C-based types into types that Rust can work with.&lt;/p&gt;
&lt;p&gt;For this, there is the excellent &lt;a href="https://crates.io/crates/winapi"&gt;winapi&lt;/a&gt; crate. It provides most of the types used in the Win32 library.&lt;/p&gt;
&lt;p&gt;Next up, we need to figure out which functions we'll actually be calling to bring our window to the front. Some quick Googling turned up &lt;a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms633539(v=vs.85).aspx"&gt;&lt;code&gt;SetForegroundWindow&lt;/code&gt;&lt;/a&gt; and &lt;a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms633548(v=vs.85).aspx"&gt;&lt;code&gt;ShowWindow&lt;/code&gt;&lt;/a&gt; which at first glance appear to do very similar things. It turns out that for this particular task, we would need both! &lt;code&gt;SetForegroundWindow&lt;/code&gt; sets the focus to the given window, but doesn't force it into the foreground--that's what &lt;code&gt;ShowWindow&lt;/code&gt; is for.&lt;/p&gt;
&lt;p&gt;According to the docs on MSDN, both of those functions live in user32.dll. The winapi crate mirrors this structure--one crate per DLL. So, we also need the &lt;a href="https://crates.io/crates/user32-sys"&gt;user32-sys&lt;/a&gt; crate to get access to bindings for those two functions.&lt;/p&gt;
&lt;p&gt;Our Rust program can finally begin to take shape. In our &lt;code&gt;Cargo.toml&lt;/code&gt;, we'll need:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;package&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;rust-vlc-finder&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;0.1.0&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;dependencies&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;winapi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;0.2&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;user32&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;0.2.0&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And at the top of &lt;code&gt;main.rs&lt;/code&gt;, we'll import our crates:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;crate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;winapi&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;crate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;user32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// tbd...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now, we know ahead of time that we need both &lt;code&gt;ShowWindow&lt;/code&gt; and &lt;code&gt;SetForegroundWindow&lt;/code&gt;. If we look at their function signatures, we can see that both of them take an &lt;code&gt;HWND&lt;/code&gt;--that is to say, a handle to a window (HWND, Handle Window, get it?).&lt;/p&gt;
&lt;p&gt;There are a lot of ways to get one of those, but the quick-and-dirty way is to just ask for it by name. The Win32 function for that is &lt;a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms633499(v=vs.85).aspx"&gt;&lt;code&gt;FindWindow&lt;/code&gt;&lt;/a&gt;, which takes an optional class name, and an (also optional) window name. Also of note, there are actually two functions here: &lt;code&gt;FindWindowA&lt;/code&gt;, the ANSI variant and &lt;code&gt;FindWindowW&lt;/code&gt;, the Unicode variant. Let's use &lt;code&gt;FindWindowA&lt;/code&gt;, because 255 characters is enough for anyone, and also, getting a UTF-16 string in Rust that's compatible with the Win32 API is a &lt;em&gt;pain&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;So, we know how to get our window handle (we use &lt;code&gt;FindWindowA&lt;/code&gt;), and we know how to make it show up afterward (we use &lt;code&gt;SetForegroundWindow&lt;/code&gt; followed by &lt;code&gt;ShowWindow&lt;/code&gt;). Now...how do we actually do that?&lt;/p&gt;
&lt;h2&gt;Getting to it&lt;/h2&gt;
&lt;p&gt;Well, can't we just do something like this?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;crate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;winapi&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;crate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;user32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Get a handle to the window based on its name.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;window_handle&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;user32&lt;/span&gt;::&lt;span class="n"&gt;FindWindowA&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;VLC Media Player&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Set it as the foreground window.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;user32&lt;/span&gt;::&lt;span class="n"&gt;SetForegroundWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;window_handle&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// And show it with the SW_RESTORE flag, which, according to the docs, maps to &amp;#39;9&amp;#39;.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;user32&lt;/span&gt;::&lt;span class="n"&gt;ShowWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;window_handle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;A big fat &lt;strong&gt;nope&lt;/strong&gt;. The compiler fails out with an &lt;code&gt;expected i8, found str&lt;/code&gt; on our "VLC Media Player" string. Also, &lt;code&gt;null&lt;/code&gt; isn't a keyword in Rust.&lt;/p&gt;
&lt;p&gt;In Rust, literal strings are of type &lt;code&gt;&amp;amp;str&lt;/code&gt;--that is, a reference to some memory that contains a string. &lt;code&gt;FindWindowA&lt;/code&gt; expects a &lt;code&gt;LPCSTR&lt;/code&gt;--a long (16-bit) pointer to a constant string.&lt;/p&gt;
&lt;p&gt;Lucky for us, the Rust standard library has a &lt;code&gt;CString&lt;/code&gt; type inside the &lt;code&gt;std::ffi&lt;/code&gt; module! Even luckier, it has an &lt;code&gt;as_ptr()&lt;/code&gt; method!&lt;/p&gt;
&lt;p&gt;Also-also, if we want to pass a null pointer, &lt;code&gt;std::ptr&lt;/code&gt; has us covered with &lt;code&gt;null_mut()&lt;/code&gt;. (It needs to be mutable, because the function might mutate it).&lt;/p&gt;
&lt;p&gt;So &lt;code&gt;main&lt;/code&gt; looks like this now:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;window_name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CString&lt;/span&gt;::&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;VLC Media Player&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;window_handle&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;user32&lt;/span&gt;::&lt;span class="n"&gt;FindWindowA&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;::&lt;span class="n"&gt;ptr&lt;/span&gt;::&lt;span class="n"&gt;null_mut&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;window_name&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;as_ptr&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;user32&lt;/span&gt;::&lt;span class="n"&gt;SetForegroundWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;window_handle&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;user32&lt;/span&gt;::&lt;span class="n"&gt;ShowWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;window_handle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;How about now? &lt;strong&gt;Still nope!&lt;/strong&gt; The compiler complains, becasue &lt;code&gt;FindWindowA&lt;/code&gt;, &lt;code&gt;SetForegroundWindow&lt;/code&gt;and &lt;code&gt;ShowWindow&lt;/code&gt; are all "unsafe" functions in Rust parlance--they don't obey the normal borrowing rules of Rust land. That unsafe marker is big red declaration that HERE BE DRAGONS.&lt;/p&gt;
&lt;p&gt;So, you need to explicitly mark any code that touches unsafe code as &lt;code&gt;unsafe&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;window_name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CString&lt;/span&gt;::&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;VLC Media Player&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;unsafe&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;window_handle&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;user32&lt;/span&gt;::&lt;span class="n"&gt;FindWindowA&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;::&lt;span class="n"&gt;ptr&lt;/span&gt;::&lt;span class="n"&gt;null_mut&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;window_name&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;as_ptr&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;user32&lt;/span&gt;::&lt;span class="n"&gt;SetForegroundWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;window_handle&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;user32&lt;/span&gt;::&lt;span class="n"&gt;ShowWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;window_handle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ta-da! It compiles, it builds, it shows VLC (if it's open)!&lt;/p&gt;
&lt;h2&gt;Extending it&lt;/h2&gt;
&lt;p&gt;This was a fun exercise, but it's a toy. It won't work if VLC is actually playing anything, because it changes its window name when it does. It becomes "&amp;lt;media file name&gt; - VLC Media Player". So we'd have to enumerate through our open windows, and look for one whose name &lt;em&gt;contains&lt;/em&gt; the phrase "VLC Media Player". Can't be that hard, right?&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/pingzing/rust-vlc-finder/blob/80446376676e96c792100b98fb958aad558decd1/src/main.rs"&gt;Well...&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;We'll leave that blog post for another day.&lt;/p&gt;
&lt;p&gt;Anyway, hope this helped! If you'd like to contact me, I'm &lt;a href="https://twitter.com/pingzingy"&gt;@pingzingy&lt;/a&gt; on Twitter, and &lt;a href="https://github.com/pingzing/"&gt;pingzing&lt;/a&gt; on GitHub!&lt;/p&gt;</content><category term="Programming"></category><category term="Rust"></category><category term="Win32"></category><category term="Windows"></category><category term="VLC"></category></entry><entry><title>Sharing Code with a PCL in MonoGame</title><link href="http://pingzing.github.io/sharing-code-with-a-pcl-in-monogame.html" rel="alternate"></link><published>2017-06-19T00:00:00+03:00</published><updated>2017-06-19T00:00:00+03:00</updated><author><name>Neil McAlister</name></author><id>tag:pingzing.github.io,2017-06-19:/sharing-code-with-a-pcl-in-monogame.html</id><summary type="html">&lt;p&gt;How to structure a MonoGame project for crossplat code-sharing&lt;/p&gt;</summary><content type="html">&lt;p&gt;I've dabbled briefly with making games in the past. I've tried &lt;a href="https://unity3d.com/"&gt;Unity&lt;/a&gt;, &lt;a href="https://love2d.org/"&gt;LÖVE&lt;/a&gt;, XNA and it's more modern successor &lt;a href="http://www.monogame.net/"&gt;MonoGame&lt;/a&gt;.
I rarely get very far, but it's always a fun little exercise. This time around, I'm trying to make a more 
determined stab at it with MonoGame. So far, I've made it further than I ever have before--I actually have working collision!&lt;/p&gt;
&lt;p&gt;&lt;img alt="Animated game collision example" src="http://pingzing.github.io/images/early-collision-test-02.gif"&gt;&lt;/p&gt;
&lt;p&gt;For this little experiment, I decided to give &lt;a href="http://www.monogame.net/"&gt;MonoGame&lt;/a&gt; another try because I'm a big ol' C# fanboy, and Lua made me angry. One thing that bit me
pretty quickly (aside from the truly frustrating lack of architectural advice) was that there weren't any guides on how to structure a multiplatform MonoGame project. &lt;/p&gt;
&lt;p&gt;One of MonoGame's promises is that it supports just about everything under the sun (even including the Nintendo Switch!), but figuring out
how to actually structure your code in a way that makes this easy seemed to be entirely absent from the internet. This post is an attempt to remedy that!&lt;/p&gt;
&lt;h1&gt;tl;dr&lt;/h1&gt;
&lt;p&gt;For those short of time:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pingzing.github.io/images/monogame-tldr-1.png" title="Make thing."&gt;&lt;img alt="Create Monogame project" src="http://pingzing.github.io\photos\monogame-tldr-1a.jpg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1.) Make your first platform project. It can target whatever it is that you want to target.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pingzing.github.io/images/monogame-tldr-2.png" title="Prepare to thing to thing"&gt;&lt;img alt="Add PCL" src="http://pingzing.github.io\photos\monogame-tldr-2a.jpg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.) Add a new project to the solution. This will be your PCL.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pingzing.github.io/images/monogame-tldr-3.png" title="Add thing to thing"&gt;&lt;img alt="Continue adding PCL" src="http://pingzing.github.io\photos\monogame-tldr-3a.jpg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.) You'll want to make sure you choose "PORTABLE Class Library", and not use "Class Library" of some flavor.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pingzing.github.io/images/monogame-tldr-4.png" title="Finish adding thing to thing"&gt;&lt;img alt="Finish adding PCL" src="http://pingzing.github.io\photos\monogame-tldr-4a.jpg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.) Choose all the targets you plan on hitting. Fewer is likely to offer you more APIs, but if you have to support one you don't select later, you may be in for pain.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pingzing.github.io/images/monogame-tldr-5.png" title="Move thing to new thing"&gt;&lt;img alt="Move Game1.cs" src="http://pingzing.github.io\photos\monogame-tldr-5a.jpg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5.) Move your Game.cs to the PCL. We'll clean up references and namespaces in a moment. Delete the copy left in the platform project.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pingzing.github.io/images/monogame-tldr-7.png" title="Add library to thing"&gt;&lt;img alt="Add MonoGame to PCL" src="http://pingzing.github.io\photos\monogame-tldr-7a.jpg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6.) Add the MonoGame.Portable NuGet package to the PCL.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pingzing.github.io/images/monogame-tldr-6.png" title="Add reference to thing"&gt;&lt;img alt="Add reference to PCL" src="http://pingzing.github.io\photos\monogame-tldr-6a.jpg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;7.) Add a reference to the PCL to the platform project.&lt;/p&gt;
&lt;p&gt;(If you get grief about the .NET version, just go to Game1's Properties, and bump the .NET Framework version to 4.5.1.)&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pingzing.github.io/images/monogame-tldr-8.png" title="Make thing look for right thing"&gt;&lt;img alt="Clean up namespaces" src="http://pingzing.github.io\photos\monogame-tldr-8a.jpg"&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;8.) Note that you could also just add a &lt;code&gt;using ClassLibrary&lt;/code&gt; statement to the top of &lt;code&gt;Program.cs&lt;/code&gt; in most cases, but because in this little example, &lt;code&gt;Game1&lt;/code&gt; is both a class name and a namespace name, it would cause problems, so I just give it the fully-qualified namespace.&lt;/p&gt;
&lt;p&gt;9.) Done!&lt;/p&gt;
&lt;h1&gt;ts;wm (Too Short; Wanted More)&lt;/h1&gt;
&lt;p&gt;&lt;br&gt;
You want the long version, eh? Well, okay. Keep on going, and hopefully you won't be disappointed.&lt;/p&gt;
&lt;h2&gt;Options&lt;/h2&gt;
&lt;p&gt;MonoGame's projects are pretty vanilla C# projects--there's not a lot of exotic build-time magic happening here. As such, you've got a quite a few options for code-sharing:&lt;/p&gt;
&lt;h3&gt;Just Use the Same Files&lt;/h3&gt;
&lt;p&gt;One approach I've seen before is to throw all your shared files into a single folder (usually named "Common") and then, in all your projects, you use Visual Studio's "Add As Link" function to add the files to your project. &lt;/p&gt;
&lt;p&gt;&lt;a href="http://pingzing.github.io/images/addaslink.png" title="It's weirdly hard to find."&gt;&lt;img alt="Add as Link example" src="http://pingzing.github.io\photos\addaslinka.jpg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This leaves the files where they are, and multiple projects can have references to the same file this way.&lt;/p&gt;
&lt;p&gt;...I don't like this solution very much. I find that it's easier to reason about a project if it mirrors the underlying folder structure as closely as possible. Using file links this way completely breaks this assumption--from Visual Studio's Solution Explorer, it looks like you have a bunch of different copies of the file in the project folders, but they're all just links to the same set of files. It also involves manual work every time you want to add a new project into the solution, and that's no fun.&lt;/p&gt;
&lt;h3&gt;A Shared Project&lt;/h3&gt;
&lt;p&gt;Another approach is to use a Shared Project. Visual Studio has better support for this, and you can just add all your cross-platform code to Shared Project. The only things you'll need to add to your platform-specific projects are initialization and bootstrapping of that platform's basic window/frame/host.&lt;/p&gt;
&lt;p&gt;...I don't like this solution either. The primary reasons are that I feel like it encourages using &lt;code&gt;#IFDEF&lt;/code&gt;s to handle platform-specific code (which is almost always bad practice), and the fact that it  doesn't generate its own assembly can make debugging and adding NuGet packages a real pain.&lt;/p&gt;
&lt;p&gt;It does have its merits though--the fact that it &lt;em&gt;does&lt;/em&gt; allow you to use &lt;code&gt;#IFDEF&lt;/code&gt;s to get at platform-specific APIs gives you an easy escape hatch if you just need to do something fast. In practice though, I've found that it's too alluring a prospect to ever use just once. Invariably, the codebase becomes riddled with &lt;code&gt;#if __IOS__&lt;/code&gt; and &lt;code&gt;#elif __ANDROID__&lt;/code&gt;, etc.&lt;/p&gt;
&lt;h3&gt;A Portable Class Library&lt;/h3&gt;
&lt;p&gt;The workhorse of cross-platform code sharing in .NET land, the PCL is similar to a Shared Project in that you'll keep all your shared code in this project. &lt;/p&gt;
&lt;p&gt;It differs from a Shared Project in that it actually produces an assembly in the form of a .DLL file, which tends to make debugging simpler. There's also no danger of having the wrong platform selected in Visual Studio, and &lt;em&gt;thinking&lt;/em&gt; you're writing cross-platform code, when you're actually only writing code that will run on one platform. In addition, adding NuGet packages tends to be much simpler: if they support PCLs, they work in the project with the shared code.&lt;/p&gt;
&lt;p&gt;One extra advantage is that if MonoGame ever gets .NET Standard support, migration from a PCL to a .NET Standard library will be fairly simple.&lt;/p&gt;
&lt;p&gt;This is my preferred solution, and what the rest of this blog post will assume.&lt;/p&gt;
&lt;h2&gt;The Solution Structure&lt;/h2&gt;
&lt;p&gt;Let me get this out of the way right up front. Here's a screenshot (more or less) of what your solution is going to look like when you're done:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pingzing.github.io/images/monogame-solution-explorer.png" title="I mean, if you're making a real game, you'll probably be supporting more than just DesktopGL."&gt;&lt;img alt="Solution Explorer screenshot" src="http://pingzing.github.io\photos\monogame-solution-explorera.jpg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Up in that screenshot there, the &lt;code&gt;monogame-test.Core&lt;/code&gt; is my PCL. It happens to target Profile 44 (Windows 8.1, .NET 4.5.1, Xamarin.iOS, Xamarin.Android, Xamarin.Mac), which happens to correspond with .NET Standard 1.2. Most of my game code will end up living in there. You can even move your &lt;code&gt;Game1.cs&lt;/code&gt; (or whatever you've renamed it) into the PCL.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;monogame-test.DesktopGL&lt;/code&gt; is a platform-specific project. Its job is mainly to set up the game's platform-specific environment. This platform is MonoGame's "DesktopGL", which by some SDL and OpenGL magic, uses a single codebase to support Windows, Mac and Linux desktop platforms. &lt;/p&gt;
&lt;p&gt;The only code in the DesktopGL project is in &lt;code&gt;Program.cs&lt;/code&gt;. It looks like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="nn"&gt;monogame_test.Core&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="nn"&gt;System&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="nn"&gt;monogame_test.DesktopGL&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;    
    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Program&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;        
&lt;span class="na"&gt;        [STAThread]&lt;/span&gt;
        &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;var&lt;/span&gt; &lt;span class="n"&gt;game&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Game&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
                &lt;span class="n"&gt;game&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Run&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Your platform-specific projects will also host content, including your &lt;code&gt;.mgcb&lt;/code&gt; file. There might be way to move this into your PCL as well, but I haven't figured it out yet.&lt;/p&gt;
&lt;h2&gt;The Deets&lt;/h2&gt;
&lt;p&gt;Some of the squirrely bits of getting this up and running include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Actually Getting MonoGame Working&lt;/li&gt;
&lt;li&gt;Dealing with things you need to talk to the Platform for&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The first is pretty simple. As of March 1 2017, MonoGame has a &lt;a href="https://www.nuget.org/packages/MonoGame.Framework.Portable/"&gt;PCL-compatible NuGet package&lt;/a&gt;. You simply add this package to your PCL, and bam. You should be up and running. If your platform-specific projects complain that MonoGame is missing, make sure you've either added it to your references manually, or you've added the appropriate NuGet package to that particular platform project.&lt;/p&gt;
&lt;p&gt;Note that apparently the PCL library is &lt;a href="https://github.com/MonoGame/MonoGame/issues/5724"&gt;not without issues&lt;/a&gt;, and it apparently has issues supporting NuGet 3.5+ (and thus UWP) at the moment, but it looks like the MonoGame guys are working on it.&lt;/p&gt;
&lt;p&gt;The second is a little more complicated, and also going to be something of an exercise left to the reader (sorry!).&lt;/p&gt;
&lt;p&gt;Part of the issue is that PCLs don't have access to certain APIs because there's no good cross-platform way to abstract them away. One example of those is file IO APIs--a PCL has no way to talk to the filesystem out of the box. In this particular case, there's an excellent library called PCLStorage that presents a cross-platform file API that PCLs can consume. But what if you need access to something that no kind soul has written a library for?&lt;/p&gt;
&lt;p&gt;One possible solution is to mimic &lt;a href="https://developer.xamarin.com/guides/xamarin-forms/application-fundamentals/dependency-service/introduction/"&gt;Xamarin's Dependency Service&lt;/a&gt;. That is, you define an interface for the thing you'd like to be able to do in your PCL, and then each of your platform-specific projects will implement that interface. How you actually go about retriving the appropiate concrete implementation of that interface at runtime is an open question. &lt;/p&gt;
&lt;p&gt;One of the simplest, dumbest solutions would be to just have a class in the PCL that looks something like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ServiceLocator&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;Dictionary&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;IService&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;_serviceRegistry&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Dictionary&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;IService&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;();&lt;/span&gt;

    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Register&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;TService&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;(&lt;/span&gt;&lt;span class="n"&gt;IService&lt;/span&gt; &lt;span class="n"&gt;implementation&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;_serviceRegistry&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;typeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TService&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;implementation&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;IService&lt;/span&gt; &lt;span class="n"&gt;Get&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;TService&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;_serviceRegistry&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;typeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TService&lt;/span&gt;&lt;span class="p"&gt;)];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;...and then your platform-specific projects register all their implementations before calling &lt;code&gt;Game.Run()&lt;/code&gt;. Then, when your PCL needs a service, it can just do &lt;code&gt;ServiceLocator.Get&amp;lt;YourService&amp;gt;().ServiceThings()&lt;/code&gt;. Of course, even with that solution, you'd want to do things like null-checking, existence-checking, etc.&lt;/p&gt;
&lt;h1&gt;That's All, Folks&lt;/h1&gt;
&lt;p&gt;Hope this helped! If you'd like to contact me, I'm &lt;a href="https://twitter.com/pingzingy"&gt;@pingzingy&lt;/a&gt; on Twitter, and &lt;a href="https://github.com/pingzing/"&gt;pingzing&lt;/a&gt; on GitHub!&lt;/p&gt;</content><category term="programming"></category><category term="games"></category><category term="monogame"></category><category term="xna"></category><category term="c#"></category><category term="csharp"></category></entry></feed>