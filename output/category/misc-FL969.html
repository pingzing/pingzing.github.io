<!DOCTYPE html>
<html lang="en">
<head>
        <title>Travel Neil - misc</title>
        <meta charset="utf-8" />
        <meta name="generator" content="Pelican" />
        <meta name="author" content="Neil" />
        <meta name="copyright" content="Neil" />
        <meta name="robots" content="noindex,follow">

        <link rel="stylesheet" href="../theme/css/main.css" type="text/css" />

        <!--[if IE]>
                <script src="https://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

        <!--[if lte IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="../css/ie.css"/>
                <script src="../js/IE8.js" type="text/javascript"></script><![endif]-->

        <!--[if lt IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="../css/ie6.css"/><![endif]-->

</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="..">Travel Neil </a></h1>
                <nav>
                    <a href="../pages/about.html">About</a>&nbsp;
                    <a href="../category/christmas-trip.html">Christmas Trip</a>&nbsp;
                    <a href="../category/life-in-finland.html">Life In Finland</a>&nbsp;
                    <a href="../category/misc.html">misc</a>&nbsp;
                </nav>
        </header><!-- /#banner -->
        
        

            <aside id="featured" class="body">
                <article>
                    <h1 class="entry-title"><a href="../sharing-code-with-a-pcl-in-monogame.html">Sharing Code with a PCL in MonoGame</a></h1> 
<footer class="post-info">
        <abbr class="published" title="2017-06-19T00:00:00+03:00">
                Mon 19 June 2017
        </abbr>
</footer><!-- /.post-info --><p>Category: programming
Tags: programming games monogame xna c# csharp
Slug: sharing-code-with-a-pcl-in-monogame
Authors: Neil McAlister
Summary: How to structure a MonoGame project for crossplat code-sharing</p>
<p>I've dabbled briefly with making games in the past. I've tried Unity, LÃ–VE, XNA and it's more modern successor MonoGame.
I rarely get very far, but it's always a fun little exercise. This time around, I'm trying to make a more 
determined stab at it with MonoGame. So far, I've made it further than I ever have before--I actually have working collision!</p>
<p><img alt="Animated game collision example" src="../images/early-collision-test-02.gif"></p>
<p>For this little experiment, I decided to give <a href="http://www.monogame.net/">MonoGame</a> another try because I'm a big ol' C# fanboy, and Lua made me angry. One thing that bit me
pretty quickly (aside from the truly frustrating lack of architectural advice) was that there weren't any guides on how to structure a multiplatform MonoGame project. </p>
<p>One of MonoGame's promises is that it supports just about everything under the sun (even including the Nintendo Switch!), but figuring out
how to actually structure your code in a way that makes this easy seemed to be entirely absent from the internet. This post is an attempt to rememdy that!</p>
<h1>tl;dr</h1>
<p>For those short of time:</p>
<ul>
<li>picture of monogame templates</li>
<li>picture of PCL template</li>
<li>picture showing to move Game1.cs to PCL</li>
<li>picture showing to add reference to PCL in platform project</li>
<li>picture showing adding MonoGame NuGet to PCL</li>
</ul>
<h1>Options</h1>
<p>MonoGame's projects are pretty vanilla C# projects--there's not a lot of exotic build-time magic happening here. As such, you've got a quite a few options for code-sharing:</p>
<h2>Just Use the Same Files</h2>
<p>One approach I've seen before is to throw all your shared files into a single folder (usually named "Common") and then, in all your projects, you use Visual Studio's "Add As Link" function to add the files to your project. </p>
<p><a href="../images/addaslink.png" title="It's weirdly hard to find."><img alt="Add as Link example" src="photos\addaslinka.jpg"></a></p>
<p>This leaves the files where they are, and multiple projects can have references to the same file this way.</p>
<p>I don't like this solution very much. I find that it's easier to reason about a project if it mirrors the underlying folder structure as closely as possible. Using file links this way completely breaks this assumption--from Visual Studio's Solution Explorer, it looks like you have a bunch of different copies of the file in the project folders, but they're all just links to the same set of files. It also involves manual work every time you want to add a new project into the solution, and that's no fun.</p>
<h2>A Shared Project</h2>
<p>Another approach is to use a Shared Project. Visual Studio has better support for this, and you can just add all your cross-platform code to Shared Project. The only things you'll need to add to your platform-specific projects are initialization and bootstrapping of that platform's basic window/frame/host.</p>
<p>I don't like this solution either. The primary reasons are that I feel like it encourages using <code>#IFDEF</code>s to handle platform-specific code (which is almost always bad practice), and the fact that it  doesn't generate its own assembly can make debugging and adding NuGet packages a real pain.</p>
<p>It does have its merits though--the fact that it <em>does</em> allow you to use <code>#IFDEF</code>s to get at platform-specific APIs gives you an easy escape hatch if you just nee to do something fast. In practice though, I've found that it's too alluring a prospect to ever use just once. Invariably, the codebase becomes riddled with <code>#if __IOS__</code> and <code>#elif __ANDROID__</code>, etc.</p>
<h2>A Portable Class Library</h2>
<p>The workhorse of cross-platform code sharing in .NET land, the PCL is similar to a Shared Project in that you'll keep all your shared code in this project. </p>
<p>It differs from a Shared Project in that it actually produces an assembly in the form of a .DLL file, which tends to make debugging simpler. There's also no danger of having the wrong platform selected in Visual Studio, and <em>thinking</em> you're writing cross-platform code, when you're actually only writing code that will run on one platform. In addition, adding NuGet packages tends to be much simpler: if they support PCLs, they work in the project with the shared code.</p>
<p>One extra advantage is that if MonoGame ever gets .NET Standard support, migration from a PCL to a .NET Standard library will be fairly simple.</p>
<p>This is my preferred solution, and what the rest of this blog post will assume.</p>
<h1>The Solution Structure</h1>
<p>Let me get this out of the way right up front. Here's a screenshot (or or less) of what your solution is going to look like when you're done:</p>
<p><a href="../images/monogame-solution-explorer.png" title="I mean, if you're making a real game, you'll probably be supporting more than just DesktopGL."><img alt="Solution Explorer screenshot" src="photos\monogame-solution-explorera.jpg"></a></p>
<p>Up in that screenshot there, the <code>monogame-test.Core</code> is my PCL. It happens to target Profile 44 (Windows 8.1, .NET 4.5.1, Xamarin.iOS, Xamarin.Android, Xamarin.Mac), which happens to correspond with .NET Standard 1.2. Most of my game code will end up living in there. You can even move your <code>Game1.cs</code> (or whatever you've renamed it) into the PCL.</p>
<p>The <code>monogame-test.DesktopGL</code> is a platform-specific project. Its job is mainly to set up the game's platform-specific environment. This platform is MonoGame's "DesktopGL", which by some SDL and OpenGL magic, uses a single codebase to support Windows, Mac and Linux desktop platforms. </p>
<p>The only code in the DesktopGL project is in <code>Program.cs</code>. It looks like this:</p>
<div class="highlight"><pre><span></span><span class="k">using</span> <span class="nn">monogame_test.Core</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">monogame_test.DesktopGL</span>
<span class="p">{</span>    
    <span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>        
<span class="na">        [STAThread]</span>
        <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">game</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Game</span><span class="p">())</span>
                <span class="n">game</span><span class="p">.</span><span class="n">Run</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Your platform-specific projects will also host content, including your <code>.mgcb</code> file. There might be way to move this into your PCL as well, but I haven't figured it out yet.</p>
<h1>The Deets</h1>
<p>Some of the squirrely bits of getting this up and running include:
 * Actually Getting MonoGame Working
 * Dealing with things you need to talk to the Platform for</p>
<p>The first is pretty simple. As of March 1 2017, MonoGame has a <a href="https://www.nuget.org/packages/MonoGame.Framework.Portable/">PCL-compatible NuGet package</a>. You simply add this package to your PCL, and bam. You should be up and running. If your platform-specific projects complain that MonoGame is missing, make sure you've either added it to your references manually, or you've added the appropriate NuGet package to that particular platform project.</p>
<p>Note that apparently the PCL library is <a href="https://github.com/MonoGame/MonoGame/issues/5724">not without issues</a>, and it apparently has issues supporting NuGet 3.5+ (and thus UWP) at the moment, but it looks like the MonoGame guys are working on it.</p>
<p>The second is a little more complicated, and also going to be something of an exercise left to the reader (sorry!).</p>
<p>Part of the issue is that PCLs don't have access to certain APIs because there's no good cross-platform way to abstract them away. One example of those is file IO APIs--a PCL has no way to talk to the filesystem out of the box. In this particular case, there's an excellent library called PCLStorage that presents a cross-platform file API that PCLs can consume. But what if you need access to something that no kind soul has written a library for?</p>
<p>One possible solution is to mimic <a href="https://developer.xamarin.com/guides/xamarin-forms/application-fundamentals/dependency-service/introduction/">Xamarin's Dependency Service</a>. That is, you define an interface for the thing you'd like to be able to do in your PCL, and then each of your platform-specific projects will implement that interface. How you actually go about retriving the appropiate concrete implementation of that interface at runtime is an open question. </p>
<p>One of the simplest, dumbest solutions would be to just have a class in the PCL that looks something like this:</p>
<div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">ServiceLocator</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">static</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">IService</span><span class="p">&gt;</span> <span class="n">_serviceRegistry</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">IService</span><span class="p">&gt;();</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Register</span><span class="p">&lt;</span><span class="n">TService</span><span class="p">&gt;(</span><span class="n">IService</span> <span class="n">implementation</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_serviceRegistry</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">TService</span><span class="p">),</span> <span class="n">implementation</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">IService</span> <span class="n">Get</span><span class="p">&lt;</span><span class="n">TService</span><span class="p">&gt;()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">_serviceRegistry</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">TService</span><span class="p">)];</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>...and then your platform-specific projects register all their implementations before calling <code>Game.Run()</code>. Then, when your PCL needs a service, it can just do <code>ServiceLocator.Get&lt;YourService&gt;().ServiceThings()</code>. Of course, even with that solution, you'd want to do things like null-checking, existence-checking, etc.</p>                </article>
            </aside><!-- /#featured -->
            </ol><!-- /#posts-list -->
            </section><!-- /#content -->
        <section id="extras" class="body">
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                     Proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="https://www.python.org/">Python</a>. Theme is using <a href="https://github.com/getpelican/pelican-themes" target="_blank">cebong</a>.
                </address><!-- /#about -->

        </footer><!-- /#contentinfo -->

</body>
</html>